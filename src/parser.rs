use std::{collections::BTreeMap, result::Result as StdResult};

use pest::{Parser, iterators::Pair};
use pest_derive::Parser;

use crate::{Binary, Value};

mod error;
pub use error::{Error, Result};

/// Parsing struct generated by pest from the grammar
///
/// Vibe-coded, and likely extremely inefficient.
#[derive(Parser)]
#[grammar = "grammar.pest"]
struct JasnParser;

/// Parse a JASN string into a Value
pub fn parse(input: &str) -> Result<Value> {
    let mut pairs = JasnParser::parse(Rule::jasn, input)?;
    let pair = pairs.next().unwrap(); // jasn rule
    let inner = pair.into_inner().next().unwrap(); // value rule
    parse_value(inner)
}

fn parse_value(pair: Pair<Rule>) -> Result<Value> {
    let rule = if pair.as_rule() == Rule::value {
        // value is a wrapper, get the actual inner rule
        pair.into_inner().next().unwrap()
    } else {
        pair
    };

    match rule.as_rule() {
        Rule::null => Ok(Value::Null),
        Rule::boolean => Ok(Value::Bool(rule.as_str() == "true")),
        Rule::integer => parse_int(rule),
        Rule::float => parse_float(rule),
        Rule::string => parse_string(rule),
        Rule::binary => parse_binary(rule),
        Rule::list => parse_list(rule),
        Rule::map => parse_map(rule),
        _ => unreachable!("Unexpected rule: {:?}", rule.as_rule()),
    }
}

fn parse_int(pair: Pair<Rule>) -> Result<Value> {
    let s = pair.as_str();

    // Remove underscores and optional '+' prefix
    let normalized = s.replace('_', "");
    let normalized = normalized.strip_prefix('+').unwrap_or(&normalized);

    // Detect and strip sign
    let (is_negative, unsigned_str) = match normalized.strip_prefix('-') {
        Some(rest) => (true, rest),
        None => (false, normalized),
    };

    // Parse based on prefix
    let uint = match unsigned_str {
        s if s.starts_with("0x") || s.starts_with("0X") => parse_int_radix(&s[2..], 16)?,
        s if s.starts_with("0b") || s.starts_with("0B") => parse_int_radix(&s[2..], 2)?,
        s if s.starts_with("0o") || s.starts_with("0O") => parse_int_radix(&s[2..], 8)?,
        _ => return Ok(Value::Int(normalized.parse::<i64>()?)),
    };

    // Apply sign to hex/binary/octal values
    let int = if is_negative { -uint } else { uint };

    Ok(Value::Int(int))
}

fn parse_int_radix(s: &str, radix: u32) -> Result<i64> {
    i64::from_str_radix(s, radix).map_err(Into::into)
}

fn parse_float(pair: Pair<Rule>) -> Result<Value> {
    let s = pair.as_str();

    // Handle special values
    let value = match s {
        "inf" | "+inf" => f64::INFINITY,
        "-inf" => f64::NEG_INFINITY,
        "nan" | "+nan" | "-nan" => f64::NAN,
        _ => s.parse::<f64>()?,
    };

    Ok(Value::Float(value))
}

fn parse_string(pair: Pair<Rule>) -> Result<Value> {
    // The string rule contains the entire string with quotes due to $
    // We need to get the inner content
    let mut inner = pair.into_inner();
    let quoted = inner.next().unwrap(); // double_quoted_string or single_quoted_string
    let content_pair = quoted.into_inner().next().unwrap(); // The actual content
    let content = content_pair.as_str();

    // Process escape sequences
    let mut result = String::with_capacity(content.len());
    let mut chars = content.chars();

    while let Some(ch) = chars.next() {
        if ch == '\\' {
            match chars.next() {
                Some('"') => result.push('"'),
                Some('\'') => result.push('\''),
                Some('\\') => result.push('\\'),
                Some('/') => result.push('/'),
                Some('b') => result.push('\u{0008}'),
                Some('f') => result.push('\u{000C}'),
                Some('n') => result.push('\n'),
                Some('r') => result.push('\r'),
                Some('t') => result.push('\t'),
                Some('u') => result.push(parse_unicode_escape(&mut chars)?),
                Some(c) => return Err(Error::InvalidEscapeChar(c)),
                None => return Err(Error::InvalidEscapeChar('\\')),
            }
        } else {
            result.push(ch);
        }
    }

    Ok(Value::String(result))
}

fn parse_unicode_escape(chars: &mut std::str::Chars) -> Result<char> {
    let hex: String = chars.take(4).collect();
    if hex.len() < 4 {
        return Err(Error::InvalidUnicodeEscape(hex));
    }
    let code =
        u32::from_str_radix(&hex, 16).map_err(|_| Error::InvalidUnicodeEscape(hex.clone()))?;
    char::from_u32(code).ok_or(Error::InvalidUnicodeCodepoint(code))
}

fn parse_binary(pair: Pair<Rule>) -> Result<Value> {
    let s = pair.as_str();

    let bytes = match s {
        s if s.starts_with("b64\"") => {
            let content = &s[4..s.len() - 1]; // Remove b64" and "
            parse_binary_b64(content)?
        }
        s if s.starts_with("h\"") => {
            let content = &s[2..s.len() - 1]; // Remove h" and "
            parse_binary_hex(content)?
        }
        _ => {
            let encoding = s.split('"').next().unwrap_or(s);
            return Err(Error::UnknownBinaryEncoding(encoding.to_string()));
        }
    };

    Ok(Value::Binary(Binary(bytes)))
}

fn parse_binary_b64(content: &str) -> Result<Vec<u8>> {
    Ok(base64::Engine::decode(
        &base64::engine::general_purpose::STANDARD,
        content,
    )?)
}

fn parse_binary_hex(content: &str) -> Result<Vec<u8>> {
    if !content.len().is_multiple_of(2) {
        return Err(Error::OddHexDigits);
    }

    (0..content.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&content[i..i + 2], 16))
        .collect::<StdResult<Vec<u8>, _>>()
        .map_err(Into::into)
}

fn parse_list(pair: Pair<Rule>) -> Result<Value> {
    let values = pair
        .into_inner()
        .map(parse_value)
        .collect::<StdResult<Vec<_>, _>>()?;
    Ok(Value::List(values))
}

fn parse_map(pair: Pair<Rule>) -> Result<Value> {
    let mut map = BTreeMap::new();

    for member in pair.into_inner() {
        let mut inner = member.into_inner();
        let key_pair = inner.next().unwrap();
        let value_pair = inner.next().unwrap();

        let key = parse_map_key(key_pair)?;
        let value = parse_value(value_pair)?;
        map.insert(key, value);
    }

    Ok(Value::Map(map))
}

fn parse_map_key(pair: Pair<Rule>) -> Result<String> {
    match pair.as_rule() {
        Rule::key => {
            // key is a wrapper rule, extract the actual string or identifier
            let actual_key = pair.into_inner().next().unwrap();
            parse_map_key(actual_key)
        }
        Rule::string => {
            if let Value::String(s) = parse_string(pair)? {
                Ok(s)
            } else {
                unreachable!("parse_string should always return Value::String")
            }
        }
        Rule::identifier => Ok(pair.as_str().to_string()),
        _ => unreachable!("Unexpected rule for map key: {:?}", pair.as_rule()),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_null() {
        assert_eq!(parse("null").unwrap(), Value::Null);
    }

    #[test]
    fn test_parse_bool() {
        assert_eq!(parse("true").unwrap(), Value::Bool(true));
        assert_eq!(parse("false").unwrap(), Value::Bool(false));
    }

    #[test]
    fn test_parse_integer() {
        assert_eq!(parse("42").unwrap(), Value::Int(42));
        assert_eq!(parse("-123").unwrap(), Value::Int(-123));
        assert_eq!(parse("0xFF").unwrap(), Value::Int(255));
        assert_eq!(parse("0b1010").unwrap(), Value::Int(10));
        assert_eq!(parse("0o755").unwrap(), Value::Int(493));
    }

    #[test]
    fn test_parse_float() {
        assert_eq!(parse("3.14").unwrap(), Value::Float(3.14));
        assert_eq!(parse("1e10").unwrap(), Value::Float(1e10));
        assert!(
            matches!(parse("inf").unwrap(), Value::Float(f) if f.is_infinite() && f.is_sign_positive())
        );
        assert!(
            matches!(parse("-inf").unwrap(), Value::Float(f) if f.is_infinite() && f.is_sign_negative())
        );
        assert!(matches!(parse("nan").unwrap(), Value::Float(f) if f.is_nan()));
    }

    #[test]
    fn test_parse_string() {
        assert_eq!(
            parse("\"hello\"").unwrap(),
            Value::String("hello".to_string())
        );
        assert_eq!(
            parse("'world'").unwrap(),
            Value::String("world".to_string())
        );
    }

    #[test]
    fn test_parse_string_escapes() {
        // Basic escapes
        assert_eq!(
            parse(r#""a\nb""#).unwrap(),
            Value::String("a\nb".to_string())
        );
        assert_eq!(
            parse(r#""a\tb""#).unwrap(),
            Value::String("a\tb".to_string())
        );
        assert_eq!(
            parse(r#""a\rb""#).unwrap(),
            Value::String("a\rb".to_string())
        );
        assert_eq!(
            parse(r#""a\\b""#).unwrap(),
            Value::String("a\\b".to_string())
        );
        assert_eq!(
            parse(r#""a\/b""#).unwrap(),
            Value::String("a/b".to_string())
        );
        assert_eq!(
            parse(r#""a\"b""#).unwrap(),
            Value::String("a\"b".to_string())
        );
        assert_eq!(
            parse(r#"'a\'b'"#).unwrap(),
            Value::String("a'b".to_string())
        );
        assert_eq!(
            parse(r#""a\bb""#).unwrap(),
            Value::String("a\u{0008}b".to_string())
        );
        assert_eq!(
            parse(r#""a\fb""#).unwrap(),
            Value::String("a\u{000C}b".to_string())
        );

        // Unicode escapes
        assert_eq!(
            parse(r#""\u0041""#).unwrap(),
            Value::String("A".to_string())
        );
        assert_eq!(
            parse(r#""\u03B1""#).unwrap(),
            Value::String("α".to_string())
        );
        assert_eq!(
            parse(r#""\u4E2D\u6587""#).unwrap(),
            Value::String("中文".to_string())
        );
        assert_eq!(
            parse(r#""Hello\u0020World""#).unwrap(),
            Value::String("Hello World".to_string())
        );
    }

    #[test]
    fn test_parse_binary() {
        // Test hex encoding
        let hex_result = parse("h\"48656c6c6f\"").unwrap();
        assert!(matches!(hex_result, Value::Binary(ref b) if b.0 == b"Hello"));

        // Test base64 encoding
        let b64_result = parse("b64\"SGVsbG8=\"").unwrap();
        assert!(matches!(b64_result, Value::Binary(ref b) if b.0 == b"Hello"));

        // Test empty binary
        let empty_hex = parse("h\"\"").unwrap();
        assert!(matches!(empty_hex, Value::Binary(ref b) if b.0.is_empty()));

        let empty_b64 = parse("b64\"\"").unwrap();
        assert!(matches!(empty_b64, Value::Binary(ref b) if b.0.is_empty()));
    }

    #[test]
    fn test_parse_list() {
        let result = parse("[1, 2, 3]").unwrap();
        assert!(matches!(result, Value::List(ref v) if v.len() == 3));
    }

    #[test]
    fn test_parse_map() {
        let result = parse("{\"key\": \"value\"}").unwrap();
        assert!(matches!(result, Value::Map(_)));
    }
}
