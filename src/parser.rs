use std::{collections::BTreeMap, result::Result as StdResult};

use pest::{Parser, iterators::Pair};
use pest_derive::Parser;

use crate::{Binary, Value};

mod error;
pub use error::{Error, Result};

/// Parsing struct generated by pest from the grammar
///
/// Vibe-coded, and likely extremely inefficient.
#[derive(Parser)]
#[grammar = "parser/grammar.pest"]
struct JasnParser;

/// Parse a JASN string into a Value
pub fn parse(input: &str) -> Result<Value> {
    let mut pairs = JasnParser::parse(Rule::jasn, input)?;
    let pair = pairs.next().unwrap(); // jasn rule
    let inner = pair.into_inner().next().unwrap(); // value rule
    parse_value(inner)
}

fn parse_value(pair: Pair<Rule>) -> Result<Value> {
    let rule = if pair.as_rule() == Rule::value {
        // value is a wrapper, get the actual inner rule
        pair.into_inner().next().unwrap()
    } else {
        pair
    };

    match rule.as_rule() {
        Rule::null => Ok(Value::Null),
        Rule::boolean => Ok(Value::Bool(rule.as_str() == "true")),
        Rule::integer => parse_int(rule),
        Rule::float => parse_float(rule),
        Rule::string => parse_string(rule),
        Rule::binary => parse_binary(rule),
        Rule::list => parse_list(rule),
        Rule::map => parse_map(rule),
        _ => unreachable!("Unexpected rule: {:?}", rule.as_rule()),
    }
}

fn parse_int(pair: Pair<Rule>) -> Result<Value> {
    let s = pair.as_str();

    // Remove underscores and optional '+' prefix
    let normalized = s.replace('_', "");
    let normalized = normalized.strip_prefix('+').unwrap_or(&normalized);

    // Detect and strip sign
    let (is_negative, unsigned_str) = match normalized.strip_prefix('-') {
        Some(rest) => (true, rest),
        None => (false, normalized),
    };

    // Parse based on prefix
    let uint = match unsigned_str {
        s if s.starts_with("0x") || s.starts_with("0X") => parse_int_radix(&s[2..], 16)?,
        s if s.starts_with("0b") || s.starts_with("0B") => parse_int_radix(&s[2..], 2)?,
        s if s.starts_with("0o") || s.starts_with("0O") => parse_int_radix(&s[2..], 8)?,
        _ => return Ok(Value::Int(normalized.parse::<i64>()?)),
    };

    // Apply sign to hex/binary/octal values
    let int = if is_negative { -uint } else { uint };

    Ok(Value::Int(int))
}

fn parse_int_radix(s: &str, radix: u32) -> Result<i64> {
    i64::from_str_radix(s, radix).map_err(Into::into)
}

fn parse_float(pair: Pair<Rule>) -> Result<Value> {
    let s = pair.as_str();

    // Handle special values
    let value = match s {
        "inf" | "+inf" => f64::INFINITY,
        "-inf" => f64::NEG_INFINITY,
        "nan" | "+nan" | "-nan" => f64::NAN,
        _ => s.parse::<f64>()?,
    };

    Ok(Value::Float(value))
}

fn parse_string(pair: Pair<Rule>) -> Result<Value> {
    // The string rule contains the entire string with quotes due to $
    // We need to get the inner content
    let mut inner = pair.into_inner();
    let quoted = inner.next().unwrap(); // double_quoted_string or single_quoted_string
    let content_pair = quoted.into_inner().next().unwrap(); // The actual content
    let content = content_pair.as_str();

    // Process escape sequences
    let mut result = String::with_capacity(content.len());
    let mut chars = content.chars();

    while let Some(ch) = chars.next() {
        if ch == '\\' {
            match chars.next() {
                Some('"') => result.push('"'),
                Some('\'') => result.push('\''),
                Some('\\') => result.push('\\'),
                Some('/') => result.push('/'),
                Some('b') => result.push('\u{0008}'),
                Some('f') => result.push('\u{000C}'),
                Some('n') => result.push('\n'),
                Some('r') => result.push('\r'),
                Some('t') => result.push('\t'),
                Some('u') => result.push(parse_unicode_escape(&mut chars)?),
                Some(c) => return Err(Error::InvalidEscapeChar(c)),
                None => return Err(Error::InvalidEscapeChar('\\')),
            }
        } else {
            result.push(ch);
        }
    }

    Ok(Value::String(result))
}

fn parse_unicode_escape(chars: &mut std::str::Chars) -> Result<char> {
    let hex: String = chars.take(4).collect();
    if hex.len() < 4 {
        return Err(Error::InvalidUnicodeEscape(hex));
    }
    let code =
        u32::from_str_radix(&hex, 16).map_err(|_| Error::InvalidUnicodeEscape(hex.clone()))?;

    // Check if this is a high surrogate (0xD800-0xDBFF)
    if (0xD800..=0xDBFF).contains(&code) {
        // This should be followed by a low surrogate
        // Peek ahead for \uXXXX pattern
        let saved_chars = chars.clone();
        if chars.next() == Some('\\') && chars.next() == Some('u') {
            let low_hex: String = chars.take(4).collect();
            if low_hex.len() == 4
                && let Ok(low_code) = u32::from_str_radix(&low_hex, 16)
            {
                // Check if this is a low surrogate (0xDC00-0xDFFF)
                if (0xDC00..=0xDFFF).contains(&low_code) {
                    // Combine surrogates into actual codepoint
                    let high = code - 0xD800;
                    let low = low_code - 0xDC00;
                    let codepoint = 0x10000 + (high << 10) + low;
                    return char::from_u32(codepoint)
                        .ok_or(Error::InvalidUnicodeCodepoint(codepoint));
                }
            }
        }
        // Not a valid surrogate pair, restore position and error
        *chars = saved_chars;
    }

    char::from_u32(code).ok_or(Error::InvalidUnicodeCodepoint(code))
}

fn parse_binary(pair: Pair<Rule>) -> Result<Value> {
    let s = pair.as_str();

    let bytes = match s {
        s if s.starts_with("b64\"") => {
            let content = &s[4..s.len() - 1]; // Remove b64" and "
            parse_binary_b64(content)?
        }
        s if s.starts_with("h\"") => {
            let content = &s[2..s.len() - 1]; // Remove h" and "
            parse_binary_hex(content)?
        }
        _ => {
            let encoding = s.split('"').next().unwrap_or(s);
            return Err(Error::UnknownBinaryEncoding(encoding.to_string()));
        }
    };

    Ok(Value::Binary(Binary(bytes)))
}

fn parse_binary_b64(content: &str) -> Result<Vec<u8>> {
    Ok(base64::Engine::decode(
        &base64::engine::general_purpose::STANDARD,
        content,
    )?)
}

fn parse_binary_hex(content: &str) -> Result<Vec<u8>> {
    if !content.len().is_multiple_of(2) {
        return Err(Error::OddHexDigits);
    }

    (0..content.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&content[i..i + 2], 16))
        .collect::<StdResult<Vec<u8>, _>>()
        .map_err(Into::into)
}

fn parse_list(pair: Pair<Rule>) -> Result<Value> {
    let values = pair
        .into_inner()
        .map(parse_value)
        .collect::<StdResult<Vec<_>, _>>()?;
    Ok(Value::List(values))
}

fn parse_map(pair: Pair<Rule>) -> Result<Value> {
    let mut map = BTreeMap::new();

    for member in pair.into_inner() {
        let mut inner = member.into_inner();
        let key_pair = inner.next().unwrap();
        let value_pair = inner.next().unwrap();

        let key = parse_map_key(key_pair)?;
        let value = parse_value(value_pair)?;
        map.insert(key, value);
    }

    Ok(Value::Map(map))
}

fn parse_map_key(pair: Pair<Rule>) -> Result<String> {
    match pair.as_rule() {
        Rule::key => {
            // key is a wrapper rule, extract the actual string or identifier
            let actual_key = pair.into_inner().next().unwrap();
            parse_map_key(actual_key)
        }
        Rule::string => {
            if let Value::String(s) = parse_string(pair)? {
                Ok(s)
            } else {
                unreachable!("parse_string should always return Value::String")
            }
        }
        Rule::identifier => Ok(pair.as_str().to_string()),
        _ => unreachable!("Unexpected rule for map key: {:?}", pair.as_rule()),
    }
}

#[cfg(test)]
mod tests {
    use rstest::rstest;

    use super::*;

    #[test]
    fn test_parse_null() {
        assert_eq!(parse("null").unwrap(), Value::Null);
    }

    #[rstest]
    #[case("true", true)]
    #[case("false", false)]
    fn test_parse_bool(#[case] input: &str, #[case] expected: bool) {
        assert_eq!(parse(input).unwrap(), Value::Bool(expected));
    }

    #[rstest]
    #[case("42", 42)]
    #[case("-123", -123)]
    #[case("0xFF", 255)]
    #[case("0b1010", 10)]
    #[case("0o755", 493)]
    fn test_parse_integer(#[case] input: &str, #[case] expected: i64) {
        assert_eq!(parse(input).unwrap(), Value::Int(expected));
    }

    #[rstest]
    #[case("2.5", 2.5)]
    #[case("1e10", 1e10)]
    fn test_parse_float_numbers(#[case] input: &str, #[case] expected: f64) {
        assert_eq!(parse(input).unwrap(), Value::Float(expected));
    }

    #[rstest]
    #[case("inf", true, true)] // is_infinite, is_sign_positive
    #[case("-inf", true, false)] // is_infinite, is_sign_negative
    fn test_parse_float_infinity(#[case] input: &str, #[case] is_inf: bool, #[case] is_pos: bool) {
        match parse(input).unwrap() {
            Value::Float(f) => {
                assert_eq!(f.is_infinite(), is_inf);
                assert_eq!(f.is_sign_positive(), is_pos);
            }
            _ => panic!("Expected Float value"),
        }
    }

    #[test]
    fn test_parse_float_nan() {
        assert!(matches!(parse("nan").unwrap(), Value::Float(f) if f.is_nan()));
    }

    #[rstest]
    #[case("\"hello\"", "hello")]
    #[case("'world'", "world")]
    fn test_parse_string(#[case] input: &str, #[case] expected: &str) {
        assert_eq!(parse(input).unwrap(), Value::String(expected.to_string()));
    }

    #[rstest]
    // Basic escapes
    #[case(r#""a\nb""#, "a\nb")]
    #[case(r#""a\tb""#, "a\tb")]
    #[case(r#""a\rb""#, "a\rb")]
    #[case(r#""a\\b""#, "a\\b")]
    #[case(r#""a\/b""#, "a/b")]
    #[case(r#""a\"b""#, "a\"b")]
    #[case(r#"'a\'b'"#, "a'b")]
    #[case(r#""a\bb""#, "a\u{0008}b")]
    #[case(r#""a\fb""#, "a\u{000C}b")]
    // Unicode escapes
    #[case(r#""\u0041""#, "A")]
    #[case(r#""\u03B1""#, "Î±")]
    #[case(r#""\u4E2D\u6587""#, "ä¸­æ–‡")]
    #[case(r#""Hello\u0020World""#, "Hello World")]
    fn test_parse_string_escapes(#[case] input: &str, #[case] expected: &str) {
        assert_eq!(parse(input).unwrap(), Value::String(expected.to_string()));
    }

    #[rstest]
    // Emoji using UTF-16 surrogate pairs
    #[case(r#""\ud83d\ude00""#, "ğŸ˜€")] // Grinning face
    #[case(r#""\ud83c\udf0d""#, "ğŸŒ")] // Earth globe
    #[case(r#""\ud83d\udc4d""#, "ğŸ‘")] // Thumbs up
    // Musical note (U+1D11E)
    #[case(r#""\ud834\udd1e""#, "ğ„")]
    // Surrogate pairs with surrounding text
    #[case(r#""Hello \ud83d\ude00 World""#, "Hello ğŸ˜€ World")]
    // Multiple surrogate pairs
    #[case(r#""\ud83d\ude00\ud83d\ude01\ud83d\ude02""#, "ğŸ˜€ğŸ˜ğŸ˜‚")]
    fn test_parse_surrogate_pairs(#[case] input: &str, #[case] expected: &str) {
        assert_eq!(parse(input).unwrap(), Value::String(expected.to_string()));
    }

    #[test]
    fn test_parse_invalid_surrogate_pairs() {
        // Lone high surrogate (no following low surrogate)
        let result = parse(r#""\ud83d""#);
        assert!(result.is_err());

        // High surrogate followed by regular character
        let result = parse(r#""\ud83dA""#);
        assert!(result.is_err());

        // High surrogate followed by another high surrogate
        let result = parse(r#""\ud83d\ud83d""#);
        assert!(result.is_err());

        // Low surrogate without preceding high surrogate
        let result = parse(r#""\ude00""#);
        assert!(result.is_err());
    }

    #[rstest]
    #[case("h\"48656c6c6f\"", b"Hello")]
    #[case("b64\"SGVsbG8=\"", b"Hello")]
    #[case("h\"\"", b"")]
    #[case("b64\"\"", b"")]
    fn test_parse_binary(#[case] input: &str, #[case] expected: &[u8]) {
        let result = parse(input).unwrap();
        assert!(matches!(result, Value::Binary(ref b) if b.0 == expected));
    }

    #[test]
    fn test_parse_list() {
        let result = parse("[1, 2, 3]").unwrap();
        assert!(matches!(result, Value::List(ref v) if v.len() == 3));
    }

    #[test]
    fn test_parse_map() {
        let result = parse("{\"key\": \"value\"}").unwrap();
        assert!(matches!(result, Value::Map(_)));
    }
}
